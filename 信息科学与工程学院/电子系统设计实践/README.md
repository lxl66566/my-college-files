# 电子设计实践

本次实践我全程使用 linux，因此这是一份不太一样的折腾记录；并且用的不是常见发行版（NixOS），可以说可复现度非常低。不过代码是平台兼容的，并且我敢保证代码质量**绝对不低**：高度模块化 + 提供了易用的用户接口 + 注释完善。

在 linux 上主要考虑编译和烧录两部分。

## 开发环境设置

### 烧录教程

linux 烧录使用 [stcgal](https://github.com/grigorig/stcgal) 即可，它是 python3 的库，用 python 包管理器就能安装。如果你使用 nix，可以通过 `nix develop && poetry install` 轻松搭好环境。至于其他环境也不难，`pip install stcgal` 一下，再随便找个 hex2bin 的软件或者让 GPT 写一个就行了。

我还尝试过 gSTC-ISP，它需要自己 make，在 nixos 上不好搞放弃了；另一个是 python2 的老库，也放弃了。linux 上烧录真的很香，不需要考虑驱动安装问题，硬写 `/dev/ttyUSB0` 就行，~~其他人用 windows 装 2012 年的驱动要考虑的就多了~~，有个同学 windows 服务里禁用了 Device Manager，结果驱动一整天装不上，蓝屏几十次（）

连好线，执行 `./dl.sh`（keil）或直接 `xmake dl`（sdcc + xmake），将开关由不通电拨向上电状态，等待数秒即可完成烧录。注意波特率一般设 9600 即可，不要过高，容易导致 MAX232 芯片过热烧毁。本次实验别人烧的芯片已经把 MAX232 库存烧完了。9600 能基本感受不到热量。

### 编译教程

编译就要麻烦许多了。我原本想使用 sdcc + xmake，然而 keil 自己的头文件有自己的魔改，sdcc 想要编译需要大量修改，我也不是专业的，因此还是随大流使用 keil……当然，是在 wine 上。然后这样做了几天，感觉自己有能力把工具链搬到 sdcc 上了，于是 20240703 尝试了一下，成功编译；不过后面由于一些问题又回到了 keil。

#### sdcc + xmake

1. 安装 sdcc 与 xmake。如果你也用 nixos，可以直接 `nix develop`。
2. 在此项目下进行配置：`xmake f -p mcs51 --toolchain=sdcc -a mcs51 --sdk=/nix/store/5jwp9pyvrrsk617qzlf9gld5ip489x4z-sdcc-4.4.0/`，把 --sdk 替换为 sdcc sdk 路径。
   - 每次 `nix develop` 都需要执行一次；并重启 clangd。否则可以直接把 sdcc 装到 user 上。
3. 对代码进行额外处理。
   - 所有的 `#include <REG52.H>` 改为 `#include <reg52.h>`。
   - 所有的类似 `sbit Motor = P1 ^ 2;` 都需要改为 `#define Motor P1_2`。原因是 sdcc 用 `sbit` 而不是 `sbit` 并且只接受常量，不接受异或运算。而 `8051.h` 里定义了 `P1_0` 等地址。如果不希望用 define，也可以 `sbit __at 0x92 MOTOR;`。bit 类似。
   - 所有的中断（`void xxx(void) interrupt 1`）改为`void xxx(void) __interrupt(1)`。
   - 所有的 `_nop_();` 换成 `__asm__("nop");`
   - 去掉所有的 `code` 关键字
4. 运行 `xmake && xmake dl` 编译并烧录。

参考资料：[使用 SDCC+xmake+VScode 打造一个自由的 51 单片机开放环境](https://www.stcaimcu.com/forum.php?mod=viewthread&tid=8013)

但是在成功后又出现了一些莫名其妙的问题，使我被迫放弃了 sdcc：

1. LED 不亮
2. 中断服务不运行

我看引脚都是对的。

#### keil

- [电子系统设计实践学生资料 2024.rar](https://cs.e.ecust.edu.cn/download/1d6453ca711af86c0b6a265c9d6416f4)
- [keil 安装包](https://cs.e.ecust.edu.cn/download/a92b89ce8b058019c770c905c0dfe2aa)

解压安装包，使用 wine 安装 `c51v954a.exe`（不安装 `MDK535.exe`！）。我用的 wine GUI 是 bottles，只要鼠标点点点就行了。安装好后，在 keil 里 _File - License Management_ 复制 CID 放到破解软件里破解。这里就不多说，网上都有教程。如果不破解，写程序时可能以代码超出长度为由终止编译。

新建一个项目，Device 选 Atmel 下的 AT89C52。如果安装时装的是 `MDK535.exe`，这里可能没有 Atmel 的选项。在 Target 里把 Xtal 晶振频率改成 11.0592。OUtput 里打开 _Create HEX file_。建好项目，导入一个 .c 文件，随便写个初始程序：

```c
#include <REG52.H>
sbit Motor = P1 ^ 2;
void main(void) {
  P2 = 0x00;
  Motor = 0;
}
```

此程序让绿灯亮，马达转。编译后能在 Objects 下看到与项目名相同的 bin 文件和 .hex 文件。编译输出的 bin 是不能直接用的，要让它输出 hex 再自己转成 bin 烧录。

课程提供的 keil v5 使用的 C 语言编译器是 C51.exe V9.54，仅持 C89 标准。因此在编程时有一些需要注意的：

- 不能使用 `inline`，`_Bool`
- 函数定义前必须声明
- 变量声明必须写在代码块最前面
- for 循环首个参数不允许定义变量
- 函数入参个数不对，居然还能过编译，6

### 编辑器

keil 烂到不配被叫做“代码编辑器“。Btw I use vscode。只需要：

1. 安装 vscode 和插件 clangd。
2. 打开项目根目录，新建一个 `.clangd` 文件，把需要忽略的报错禁用（[这里是我的](./.clangd)）。
3. 在设置里将 clangd 设为默认格式化程序，并开启 format on save。

就可以愉快地写代码了。

### 串口调试

在 windows 下貌似有很简单的串口调试工具，只要点点点就行了，而在 linux 上要麻烦一点。我使用 minicom。`sudo minicom -s` 打开设置：

1. 在 _串口设置_ 中，_A 串行设备_ 改为 `/dev/ttyUSB0`，_E Bps/Par/Bits_ 改为 9600 8N1，然后 enter 返回
2. _保存设置为 dfl_， _离开本画面_
3. 连上就能看到串口输出了。

之后只要 `sudo minicom` 进入即可。注意烧录时不能开启 minicom。

常用的快捷键：`Ctrl-A q` 退出，`Ctrl-A c` 清屏。

## 程序部分

参考资料：[电子系统设计实践——软件编写](https://blog.csdn.net/weixin_42024288/article/details/118878486)，学长的程序

### 字符表

本来我打算直接去网上抄一般八段共阴数码管的字符表的，结果你校这玩意不太标准，显示的位置跟乱序差不多，非常扭曲（举个例子，小数点显示是 0x02,这玩意居然在中间！）。网上抄不到表，让 GPT4o 写也写不出来，我只好自己写了一个，详见 [src/display.c](./src/display.c)。其实写起来也很快就是了。

### 温度传感器

PPT 上给的 DS18B20_DQ 的定义是 `sbit DS18B20_DQ = P1 ^ 4;`，但是实际上地址是 `P1 ^ 3`。。。我真服了，我说怎么读出来一直都是两个 `0xFF`，初始化一直都是 Err。。后来发现即使温度传感器没问题，也会返回高电平 err（

然后首次读温度传感器值时会出现神奇的 85.00。可以在初始化时直接读一次消除。

### 电机占空比

电机占空比的延时是通过中断来调的，如果手动 empty_loop 可能会阻塞主循环。而在非电机调速时可以把全局中断关了，避免影响显示。

然后我尝试调高中断频率，失败了，只能维持在几十 Hz。因此在 `motor.c` 里用了个折算技巧。不过实际跑的时候也不会有人管就是了。

### EEPROM

不想了解底层原理，PPT 也没有给代码，好在有学长代码能直接开抄。然而我测试时一直读出的都是 0xFF，对照了半天代码也没发现问题。拿别人板子一测，代码没有问题，芯片是坏的。。。换了芯片就好了。郁闷。

### 菜单

各模块都写好，万事具备以后我才开始设计菜单和界面。如果模块写得好，这一步的工作量并不算太大……？然后我就遇到了菜单设计的问题。

我最开始写的设计是经典的 layer 层 + menu 层的菜单，具体的代码可以看[这里](https://github.com/lxl66566/my-college-files/blob/e6169aa1e692080fff553b0a82399ed084bd5557/信息科学与工程学院/电子系统设计实践/src/main.c)。这样的代价是：1 耦合度非常高，写起来很痛苦 2 程序不断跑主循环，所有函数都必须非阻塞。然后我写了一半感觉不太对，把代码抹掉重新设计菜单逻辑。在跟我的前端舍友讨论后，我和他分别提出了一个设计：

1. 我的设计：所有函数都是阻塞的，全部塞 `while(1)` 和按键判断，用 macro 减少代码重复。
2. 舍友的设计：提前规划好一颗状态树和所有节点，按键只负责在状态树上移动，逻辑根据当前的节点实现。

想了半天，我还是决定先使用我的设计，毕竟 C 写数据结构实在是太麻烦。

然后就遇到了神奇的 bug，为什么好好的代码不对呢？让 GPT 写了一个打印串口的函数，调试以后发现，函数中临时变量 menu 的值被改了！后来发现入参也会变化。但是我的函数是 `void(void)`，理论上是改不了连地址都没有的入参和局部参数的。感觉是栈溢出了。

解决办法是把入参放全局。虽然这样不能实现代码复用有点不爽，但是不会解决，也只能妥协了。

## 一些想说的

~~实际写代码都没怎么写，天天折腾环境，不务正业玩 nixos，来实验室偷电偷空调，岂不美哉！~~

帮同学调代码遇到一些非常神奇的 bug，最神奇的一个是把 `for (j = 0;j < 4;j++);` 改成 `for (j = 4;j > 0; j--);` 就能跑了，j 是 `unsigned char`（[ref](https://t.me/withabsolutex/1727)），实在是太神奇了。所以写代码时尽量注意作用域，能写 .c 就别写在 .h，用 clang 看看警告，生活会很美好。
