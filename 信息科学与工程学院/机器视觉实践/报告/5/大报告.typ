#import "../template.typ": *

#show: project.with(
  title: "5",
  authors: ("absolutex",),
)

// heading
#set heading(numbering: "1.1.1.1")
#show heading: it => locate(loc => {
  set text(font: 字体.黑体)
  set par(first-line-indent: 0pt)
  let levels = counter(heading).at(loc)
  let deepest = if levels != () {
    levels.last()
  } else {
    1
  }
  if it.level == 1 {
    set text(字号.四号)
    if it.numbering != none {
      numbering("一、", deepest)
    }
    it.body
  } else if it.level == 2 {
    set text(size: 字号.小四)
    if it.numbering != none {
      numbering("1.1 ", ..levels)
      h(3pt, weak: true)
    }
    it.body
  } else if it.level == 3 {
    set text(size: 字号.五号)
    if it.numbering != none {
      numbering("1.1.1 ", ..levels)
      h(3pt, weak: true)
    }
    it.body
  }
})
#let title(title) = {
  pagebreak(weak: true)
  align(center)[#text(size: 字号.小二, font: 字体.黑体, title)]
}

#title("基于LSB最低有效位隐写技术的图像隐写术研究")

= 课程设计目标

+ 深入理解LSB最低有效位隐写技术的基本原理及其在图像隐写中的应用。
+ 掌握使用LSB技术进行信息隐藏的方法。
+ 实现一个简单的LSB隐写解密系统，能够将文本消息嵌入到图像中，并能从图像中恢复消息。
+ 对比分析不同参数设置下（如不同的载体图像、不同的嵌入容量等）对隐写效果的影响。

= 课程设计开发环境

+ Windows 11
+ uv Python 包管理器
+ Python 3.13

= LSB 隐写算法简介

LSB 最低有效位是广泛使用的一种隐写技术，LSB隐写就是将信息放入RGB颜色分量的最低二进制位，也就是最低有效位（LSB）。由于人眼对图像细微变化的敏感度较低，因此这种方法可以在不明显改变图像外观的情况下嵌入数据。

= 算法实现

== 算法框架

+ 预处理阶段：准备载体图像和要隐藏的消息。
+ 加密阶段：将文本消息转换为二进制格式。根据载体图像的大小确定可以隐藏的最大信息量。修改载体图像的像素值，将信息编码进每个像素的最低有效位。
+ 解密阶段：提取嵌入了信息的图像。读取每个像素的最低有效位，重组为原始消息。
+ 后处理阶段：验证解密出的消息是否正确无误。

== 算法流程

隐写流程：

+ 信息编码为二进制序列，并在其后添加 64 个 0 作为结束符。
+ 计算隐写内容长度，并将每一个 bit 平均地分散到图像（的蓝色通道）中。这里分散的值使用的是 jump，也就是同一行中有效 bit 的距离。
+ 对于每一张图像，通过约定好的伪随机数序列，在图片绿色通道上选取 $31 times 8$ 个点（共计 31 bytes），存储 31 次 jump 数字本身。
  + 使用绿色通道的目的是不让 jump 值与密文相互覆盖影响。
+ 输出图像。

混淆流程：

- 对隐写后的图像进行不同的处理。（原图像，椒盐噪声，高斯噪声，色块切割）

恢复流程：

+ 打开处理后的图像
+ 从预定的 31 个位置读取 jump 数据。在图片变换下，jump 可能会发生改变，这里取出现次数较多的 jump 值。
+ 根据 jump 值提取图片对应 bit 处的二进制信息序列。
+ 序列遇到连续 8 个 0 即认为序列结束。
+ 将序列解码为原始信息。

此处设计的算法具有一些特点：

+ 信息被均匀分散到图像中，因此在图像部分区域破损的情况下能够较好地恢复信息。
+ 多处分散备份 jump 值也是出于此考虑。

核心代码如下，具体细节写在了注释中。

#include_code("../src/watermark/LSB.py")

= 实验结果

#figure(
  image("LSB.jpg", width: 50%),
  caption: [LSB 法原图与隐写图对比],
)

这里验证了 LSB 隐写并不会对图像造成肉眼可见的影响。

接下来展示不同条件下的密文恢复。

#figure(
  image("trans.jpg", width: 70%),
  caption: [验证干扰下的恢复。从左到右：原图 椒盐噪声 高斯噪声 色块切割],
)

== 无干扰条件下

```
请输入密文内容：1234
INFO:root:jump: 255
INFO:root:got image shape : (1440, 1080)
INFO:root:most common jump: (255, 31)
获取密文： 1234
```

可以看到所有 31 个 jump 值均未改变，成功提取出密文。

== 椒盐噪声

```
请输入密文内容：1234
INFO:root:got image shape : (1440, 1080)
INFO:root:most common jump: 255, 个数为 25
获取密文： 1234    !
```

可以看到 jump 成功读取，但是在获取密文时没有正确读取结束符，导致读取长度大于实际信息长度。该算法对椒盐噪声干扰抗性一般。因为椒盐噪声本身是全图随机的，这降低了将 LSB 的信息位分散到全图的抗干扰意义。

== 高斯噪声

```
请输入密文内容：1234
INFO:root:jump: 255
INFO:root:got image shape : (1440, 1080)
WARNING:root:相同的 jump 不够多，可能有干扰，jump 为 239， 个数为 2
zB{Ìe,mkRµ)@!Â¦áiâ¬+¯=J5¼ÚçwÊv§{Îó¥9LcÆRç9ÜÆ³ç{Þ÷­û½-^ÿü­kÞsÞs×¹¥¦5½!)@+\B¹¥PÄCÊs3µé¾ Á.y¡[ÌB^öR&!aµ³¯g8qLd :´w¥¯
....
```

可以看到 jump 未能成功读取，信息获取错误。该算法无法抗高斯噪声的干扰：高斯噪声是全图影响，并且对于像素最后一位影响很大，几乎等于完全随机错位。

== 色块切割

```
请输入密文内容：1234
INFO:root:jump: 255
INFO:root:got image shape : (1440, 1080)
INFO:root:most common jump: 255, 个数为 30
获取密文： 1234
```

对于色块切割干扰，该算法拥有非常高的抗干扰能力。不如说，算法的核心思想是将色块分散到全图，这一开始就是为了色块切割设计的。局部的色块切割只会丢失很小一部分信息，均匀分散能保证大多数信息的完整性。

= 心得体会

通过本次课程设计，我深入学习了LSB（最低有效位）隐写技术的原理和应用，并成功实现了基于LSB技术的信息隐藏系统。但是在实现过程中也遇到了一些问题。

本次实验多次将图像的 RGB 三通道分离，在处理后再将三通道合并回图片。而在 LSB 的测试中，一直出现图片 jump 和信息提取失败的情况，无论何种干扰（特别是色块切割干扰），jump 正确的个数都小于 3。我将写入信息时和解码时对整个 G 通道矩阵打印并 diff，发现比信息量多得多的像素发生了漂移，也就是灰度值出现变化，幅度在 1-3 左右。这对于 LSB 是致命性的灾难，因为这意味着最低位发生了改变。

最后经过实验我发现这个现象是由于 JPG 格式图像导致的精度损失，因为 JPG 图像是有损压缩格式，将图片保存回 jpg 时会破坏写入的信息。将图像格式换为 PNG 后，观测到了期望结果。

通过这次课程设计，我深刻体会到了理论与实践相结合的重要性。只有将理论知识应用于实际项目中，才能真正理解其内涵和应用价值。本次课程设计不仅提升了我的编程能力和图像处理技能，还增强了我对信息安全领域的兴趣。在未来的学习和研究中，我将继续关注和探索更多的隐写技术和信息安全方法，为保障数字时代的网络安全贡献自己的力量。