#import "../../template.typ": *
#import "@preview/tablem:0.1.0": tablem


#show: project.with(
  title: "理论 6",
  authors: (
    "absolutex",
  )
)
// P3、P5、 P14、P15、 P21、P31

= 理论作业6

== P3 假设某分组的信息部分（图6.3中的D）包含10字节，它由字符 “Internet” 的8比特无符号二进制ASCII表示组成。对该数据计算因特网检验和。

```python
#! /usr/bin/env python3
s = sum(map(ord, "Internet"))  # =841
s = int(s / (1 << 8)) + s % (1 << 8)  # 进位 =76, 01001100
s = ~s  # 补码 =-77, 10110100
```

`checksum = 10110100`

== P5 考虑5比特生成多项式，G=10011，并且假设D的值为101010101010。R的值是什么?

```python
#! /usr/bin/env python3
G=0b10011
D=0b101010101010
r=5
(D << r )% G
# = 17
```

== P14.如图6-33所示，考虑通过两台路由器互联的3个局域网。

=== a.对所有的接口分配IP地址。对子网1使用形式为192.168.1.xxx的地址，对子网2使用形式为192.168.2.xxx 的地址，对子网3使用形式为192.168.3.xxx的地址。

#tablem[
  |主机|ip|
  |---|---|
  |A|192.168.1.2|
  |B|192.168.1.3|
  |C|192.168.2.2|
  |D|192.168.2.3|
  |E|192.168.3.2|
  |F|192.168.3.3|
  |左路由左侧接口|192.168.1.1|
  |左路由右侧接口|192.168.2.1|
  |右路由左侧接口|192.168.2.4|
  |右路由右侧接口|192.168.3.1|
]
#linebreak()

=== b.为所有的适配器分配 MAC 地址。

由于所有设备的MAC均不同且没有限制，因此直接使用 

*`MAC-A`...`MAC-F`, MAC-R1-左，MAC-R1-右，MAC-R2-左，MAC-R2-右*

来指代适配器 MAC 地址。

=== c.考虑从主机E向主机B发送一个IP数据报。假设所有的ARP 表都是最新的。就像在6.4.1节中对单路由器例子所做的那样，列举出所有步骤。

1. 主机E发送IP数据报，其中MAC地址指示了 MAC-R2-右。
2. 路由器R2收到IP数据报，查表发现子网地址在子网1内，需要通过接口 MAC-R1-右。
3. 路由器R2将IP数据报发给R1（MAC-R1-左）。
4. R1收到IP数据报，查表查到了 MAC-B，通过接口 MAC-R1-左 发出。


=== d.重复（c），现在假设在发送主机中的ARP 表为空(并且其他表都是最新的)。

1. 主机E发送IP数据报，其中MAC地址指示了 MAC-R2-右。
2. 路由器R2收到IP数据报，没发现MAC-B地址，因此广播ARP请求。
3. R1 收到ARP请求，发现自己有MAC-B，于是回应请求。
3. 路由器R2收到回应，将MAC-R1-右写入ARP表，并交出数据报。
4. R1收到IP数据报，查表查到了 MAC-B，通过接口 MAC-R1-左 发出。