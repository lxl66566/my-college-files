% Cp：大小为 Kp 的序列数
% Kp：代码段后较长的序列（包括 CRC 位）
% Cm：大小 Km 序列的编号
% Km：代码段（包括 CRC 位）后尺寸较短的序列
% F：填充位数
% Out_data：功能代码段的输出数据
% Info_data：功能代码段的输入数据
% C：大小为 Kp+Km 序列的编号

function [Cp, Kp, Cm, Km, F, Out_data, C] = TDLTE_Cdblk_seg1(Info_data)
    %  Cdblk_seg 代码块分割和CRC附加

    K = [40 48 56 64 72 80 88 96 104 112 120 128 136 144 152 ...
            160 168 176 184 192 200 208 216 224 232 240 248 256 ...
            264 272 280 288 296 304 312 320 328 336 344 352 360 ...
            368 376 384 392 400 408 416 424 432 440 448 456 464 ...
            472 480 488 496 504 512 528 544 560 576 592 608 624 ...
            640 656 672 688 704 720 736 752 768 784 800 816 832 ...
            848 864 880 896 912 928 944 960 976 992 1008 1024 ...
            1056 1088 1120 1152 1184 1216 1248 1280 1312 1344 ...
            1376 1408 1440 1472 1504 1536 1568 1600 1632 1664 ...
            1696 1728 1760 1792 1824 1856 1888 1920 1952 1984 ...
            2016 2048 2112 2176 2240 2304 2368 2432 2496 2560 ...
            2624 2688 2752 2816 2880 2944 3008 3072 3136 3200 ...
            3264 3328 3392 3456 3520 3584 3648 3712 3776 3840 ...
            3904 3968 4032 4096 4160 4224 4288 4352 4416 4480 ...
            4544 4608 4672 4736 4800 4864 4928 4992 5056 5120 ...
            5184 5248 5312 5376 5440 5504 5568 5632 5696 5760 ...
            5824 5888 5952 6016 6080 6144];

    Z = 6144; % 最大码块长度
    Info_len = length(Info_data); % 输入数据的长度

    if (Info_len <= Z)
        L = 0; % CRC附加长度为0，不需要添加CRC
        C = 1; % 只有一个码块
        Bt = Info_len; % 码块分割后的长度等于输入长度
    else
        L = 24; % CRC附加长度为24，需要添加CRC
        C = ceil(Info_len / (Z - L)); % 码块分割后的码块数量
        Bt = Info_len + C * L; % 码块分割后的总长度
    end

    i = 1;

    while (K(i) * C < Bt)
        i = i + 1;
    end

    Kp = K(i); % 较长的码块长度

    if (C == 1)% 只有一个码块
        Cp = 1;
        Km = 0;
        Cm = 0;
    else % 多于一个码块，需要分成两种长度
        Km = K(i - 1); % 较短的码块长度。
        deltaK = Kp - Km;
        Cm = floor((C * Kp - Bt) / deltaK); % 较短码块的数量
        Cp = C - Cm; % 较长码块的数量
    end

    F = Cp * Kp + Cm * Km - Bt; % 填充比特的数量
    Out_data = zeros(C, Kp); % 初始化输出数据矩阵

    if (C == 1)% 只有一个码块，总码块长度为Kp，不添加CRC
        Out_data(1, F + 1:Kp) = Info_data;
    else
        k = F + 1;
        s = 1;

        for r = 1:C

            if (r < Cm + 1)
                Kr = Km - L; % 较短码块的长度（不包括CRC）
            else
                Kr = Kp - L; % 较长码块的长度（不包括CRC）
            end

            while k < Kr + 1
                Out_data(r, k) = Info_data(1, s);
                k = k + 1;
                s = s + 1;
            end

            k = 1;
            Out_data(r, 1:Kr + L) = CRC_attach(Out_data(r, 1:Kr), 24, 1); % 添加CRC
        end

    end

    C = Cp + Cm; % 总码块数量

end
