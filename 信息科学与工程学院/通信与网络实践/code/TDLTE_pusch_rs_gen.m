% 这段代码是一个用于生成 LTE 系统中物理上行链路共享信道（PUSCH）参考信号（RS）的MATLAB函数。
% 在无线通信系统中，参考信号用于接收端进行信道估计等操作，以提高数据传输的可靠性和效率。

%pusch channel reference signal generator
function [out, basic_out] = TDLTE_pusch_rs_gen(rbnum, group_hop_flag, seq_hop_flag, slotno, cellid, deltass, ...
        ndmrs1, cyc_shift, symbol_index)

    % rbnum：占用的资源块(Resource Block, RB)数量。
    % group_hop_flag：组跳频(Group Hopping)启用标志，决定是否启用组跳频。
    % seq_hop_flag：序列跳频(Sequence Hopping)标志，决定是否启用序列跳频。
    % slotno：时隙编号。
    % cellid：小区ID。
    % deltass：高层配置的组跳频参数。
    % ndmrs1：广播中配置的参数，通常与参考信号的循环移位有关。
    % cyc_shift：DCI（下行控制信息）调度信息中提供的循环移位值。
    % symbol_index：符号索引，虽然在这个函数中没有直接使用，但可能是为了兼容其他调用场景而保留的参数。

    prime_table = [11, 23, 31, 47, 59, 71, 83, 89, 107, 113, 131, 139, 151, 167, 179, 191, 199, 211, 227, 239, ...
                    251, 263, 271, 283, 293, 311, 317, 331, 347, 359, 367, 383, 389, 401, 419, 431, 443, 449, 467, 479, ...
                    491, 503, 509, 523, 523, 547, 563, 571, 587, 599, 607, 619, 631, 647, 659, 661, 683, 691, 701, 719, ...
                    727, 743, 751, 761, 773, 787, 797, 811, 827, 839, 839, 863, 863, 887, 887, 911, 919, 929, 947, 953, ...
                    971, 983, 991, 997, 1019, 1031, 1039, 1051, 1063, 1069, 1091, 1103, 1109, 1123, 1129, 1151, 1163, 1171, 1187, 1193, 2003]; %
    ndmrs2_table = [0, 2, 3, 4, 6, 8, 9, 10];
    fai_12sc = [-1, 1, 3, -3, 3, 3, 1, 1, 3, 1, -3, 3;
            1, 1, 3, 3, 3, -1, 1, -3, -3, 1, -3, 3;
            1, 1, -3, -3, -3, -1, -3, -3, 1, -3, 1, -1;
            -1, 1, 1, 1, 1, -1, -3, -3, 1, -3, 3, -1;
            -1, 3, 1, -1, 1, -1, -3, -1, 1, -1, 1, 3;
            1, -3, 3, -1, -1, 1, 1, -1, -1, 3, -3, 1;
            -1, 3, -3, -3, -3, 3, 1, -1, 3, 3, -3, 1;
            -3, -1, -1, -1, 1, -3, 3, -1, 1, -3, 3, 1;
            1, -3, 3, 1, -1, -1, -1, 1, 1, 3, -1, 1;
            1, -3, -1, 3, 3, -1, -3, 1, 1, 1, 1, 1;
            -1, 3, -1, 1, 1, -3, -3, -1, -3, -3, 3, -1;
            3, 1, -1, -1, 3, 3, -3, 1, 3, 1, 3, 3;
            1, -3, 1, 1, -3, 1, 1, 1, -3, -3, -3, 1;
            3, 3, -3, 3, -3, 1, 1, 3, -1, -3, 3, 3;
            -3, 1, -1, -3, -1, 3, 1, 3, 3, 3, -1, 1;
            3, -1, 1, -3, -1, -1, 1, 1, 3, 1, -1, -3;
            1, 3, 1, -1, 1, 3, 3, 3, -1, -1, 3, -1;
            -3, 1, 1, 3, -3, 3, -3, -3, 3, 1, 3, -1;
            -3, 3, 1, 1, -3, 1, -3, -3, -1, -1, 1, -3;
            -1, 3, 1, 3, 1, -1, -1, 3, -3, -1, -3, -1;
            -1, -3, 1, 1, 1, 1, 3, 1, -1, 1, -3, -1;
            -1, 3, -1, 1, -3, -3, -3, -3, -3, 1, -1, -3;
            1, 1, -3, -3, -3, -3, -1, 3, -3, 1, -3, 3;
            1, 1, -1, -3, -1, -3, 1, -1, 1, 3, -1, 1;
            1, 1, 3, 1, 3, 3, -1, 1, -1, -3, -3, 1;
            1, -3, 3, 3, 1, 3, 3, 1, -3, -1, -1, 3;
            1, 3, -3, -3, 3, -3, 1, -1, -1, 3, -1, -3;
            -3, -1, -3, -1, -3, 3, 1, -1, 1, 3, -3, -3;
            -1, 3, -3, 3, -1, 3, 3, -3, 3, 3, -1, -1;
            3, -3, -3, -1, -1, -3, -1, 3, -3, 3, 1, -1];
    fai_24sc = [-1, 3, 1, -3, 3, -1, 1, 3, -3, 3, 1, 3, -3, 3, 1, 1, -1, 1, 3, -3, 3, -3, -1, -3;
            -3, 3, -3, -3, -3, 1, -3, -3, 3, -1, 1, 1, 1, 3, 1, -1, 3, -3, -3, 1, 3, 1, 1, -3;
            3, -1, 3, 3, 1, 1, -3, 3, 3, 3, 3, 1, -1, 3, -1, 1, 1, -1, -3, -1, -1, 1, 3, 3;
            -1, -3, 1, 1, 3, -3, 1, 1, -3, -1, -1, 1, 3, 1, 3, 1, -1, 3, 1, 1, -3, -1, -3, -1;
            -1, -1, -1, -3, -3, -1, 1, 1, 3, 3, -1, 3, -1, 1, -1, -3, 1, -1, -3, -3, 1, -3, -1, -1;
            -3, 1, 1, 3, -1, 1, 3, 1, -3, 1, -3, 1, 1, -1, -1, 3, -1, -3, 3, -3, -3, -3, 1, 1;
            1, 1, -1, -1, 3, -3, -3, 3, -3, 1, -1, -1, 1, -1, 1, 1, -1, -3, -1, 1, -1, 3, -1, -3;
            -3, 3, 3, -1, -1, -3, -1, 3, 1, 3, 1, 3, 1, 1, -1, 3, 1, -1, 1, 3, -3, -1, -1, 1;
            -3, 1, 3, -3, 1, -1, -3, 3, -3, 3, -1, -1, -1, -1, 1, -3, -3, -3, 1, -3, -3, -3, 1, -3;
            1, 1, -3, 3, 3, -1, -3, -1, 3, -3, 3, 3, 3, -1, 1, 1, -3, 1, -1, 1, 1, -3, 1, 1;
            -1, 1, -3, -3, 3, -1, 3, -1, -1, -3, -3, -3, -1, -3, -3, 1, -1, 1, 3, 3, -1, 1, -1, 3;
            1, 3, 3, -3, -3, 1, 3, 1, -1, -3, -3, -3, 3, 3, -3, 3, 3, -1, -3, 3, -1, 1, -3, 1;
            1, 3, 3, 1, 1, 1, -1, -1, 1, -3, 3, -1, 1, 1, -3, 3, 3, -1, -3, 3, -3, -1, -3, -1;
            3, -1, -1, -1, -1, -3, -1, 3, 3, 1, -1, 1, 3, 3, 3, -1, 1, 1, -3, 1, 3, -1, -3, 3;
            -3, -3, 3, 1, 3, 1, -3, 3, 1, 3, 1, 1, 3, 3, -1, -1, -3, 1, -3, -1, 3, 1, 1, 3;
            -1, -1, 1, -3, 1, 3, -3, 1, -1, -3, -1, 3, 1, 3, 1, -1, -3, -3, -1, -1, -3, -3, -3, -1;
            -1, -3, 3, -1, -1, -1, -1, 1, 1, -3, 3, 1, 3, 3, 1, -1, 1, -3, 1, -3, 1, 1, -3, -1;
            1, 3, -1, 3, 3, -1, -3, 1, -1, -3, 3, 3, 3, -1, 1, 1, 3, -1, -3, -1, 3, -1, -1, -1;
            1, 1, 1, 1, 1, -1, 3, -1, -3, 1, 1, 3, -3, 1, -3, -1, 1, 1, -3, -3, 3, 1, 1, -3;
            1, 3, 3, 1, -1, -3, 3, -1, 3, 3, 3, -3, 1, -1, 1, -1, -3, -1, 1, 3, -1, 3, -3, -3;
            -1, -3, 3, -3, -3, -3, -1, -1, -3, -1, -3, 3, 1, 3, -3, -1, 3, -1, 1, -1, 3, -3, 1, -1;
            -3, -3, 1, 1, -1, 1, -1, 1, -1, 3, 1, -3, -1, 1, -1, 1, -1, -1, 3, 3, -3, -1, 1, -3;
            -3, -1, -3, 3, 1, -1, -3, -1, -3, -3, 3, -3, 3, -3, -1, 1, 3, 1, -3, 1, 3, 3, -1, -3;
            -1, -1, -1, -1, 3, 3, 3, 1, 3, 3, -3, 1, 3, -1, 3, -1, 3, 3, -3, 3, 1, -1, 3, 3;
            1, -1, 3, 3, -1, -3, 3, -3, -1, -1, 3, -1, 3, -1, -1, 1, 1, 1, 1, -1, -1, -3, -1, 3;
            1, -1, 1, -1, 3, -1, 3, 1, 1, -1, -1, -3, 1, 1, -3, 1, 3, -3, 1, 1, -3, -3, -1, -1;
            -3, -1, 1, 3, 1, 1, -3, -1, -1, -3, 3, -3, 3, 1, -3, 3, -3, 1, -1, 1, -3, 1, 1, 1;
            -1, -3, 3, 3, 1, 1, 3, -1, -3, -1, -1, -1, 3, 1, -3, -3, -1, 3, -3, -1, -3, -1, -3, -1;
            -1, -3, -1, -1, 1, -3, -1, -1, 1, -1, -3, 1, 1, -3, 1, -3, -3, 3, 1, 1, -1, 3, -1, -1;
            1, 1, -1, -1, -3, -1, 3, -1, 3, -1, 1, 3, 1, -1, 3, 1, 3, -3, -3, 1, -1, -1, 1, 3];

    % prime_table：一个预定义的质数列表，用于后续确定序列长度。
    % ndmrs2_table：一个预定义的数值表，用于计算ncs值。
    % fai_12sc：一个预定义的矩阵，用于生成长度为12个子载波的基本序列。

    %确定组号u的具体取值；
    if (group_hop_flag == 0)%组跳频无效
        fghns = 0;
    else
        cinit = floor(cellid / 30);
        cgroup = pseudo_random_seq_gen(cinit, 180);
        sum = 0;

        for (iii = 0:7)
            sum = sum + cgroup(8 * slotno + iii + 1) * (2^iii);
        end

        fghns = mod(sum, 30);
    end

    fss = mod(cellid, 30);
    fss = mod((fss + deltass), 30);
    u = mod(fghns + fss, 30);

    %确定组内序列号v的具体取值；
    if (rbnum < 6)
        v = 0;
    elseif (group_hop_flag == 0) & (seq_hop_flag == 1)
        cinit = floor(cellid / 30) * 32 + fss;
        cseq = pseudo_random_seq_gen(cinit, 180);
        v = cseq(slotno);
    else
        v = 0;
    end

    %基本序列生成
    mrssc = rbnum * 12;

    if (rbnum == 1)%序列长度为12个子载波

        for (iii = 1:mrssc)
            ruvns(iii) = exp(j * pi / 4 * fai_12sc((u + 1), iii)); %
        end

    elseif (rbnum == 2)%序列长度为24个子载波

        for (iii = 1:mrssc)
            ruvns(iii) = exp(j * pi / 4 * fai_24sc((u + 1), iii)); %
        end

    else %序列长度大于等于36个子载波。
        nrszc = prime_table(rbnum); %by maoxuewei @2090324
        qs = nrszc * (u + 1) / 31;
        q = floor(qs + 0.5) + v * ((-1)^(floor(2 * qs)));

        for (iii = 1:nrszc)
            xqm(iii) = exp(-j * pi * q * (iii - 1) * iii / nrszc);
        end

        for (iii = 1:mrssc)
            ruvns(iii) = xqm(mod((iii - 1), nrszc) + 1);
        end

    end

    basic_out = ruvns;
    %计算a的值,并得到最后的序列
    cinit = floor(cellid / 30) * 32 + fss;
    cseq = pseudo_random_seq_gen(cinit, 1120); % based on 3GPP 36211-850
    nprs = 0;

    for (iii = 0:7)
        nprs = nprs + cseq(slotno * 8 * 7 + iii + 1) * (2^iii);
    end

    ncs = mod(ndmrs1 + ndmrs2_table(cyc_shift + 1) + nprs, 12);
    alpha = 2 * pi * ncs / 12;

    for (iii = 0:mrssc - 1)
        temp1 = exp(j * iii * alpha);
        out(iii + 1) = temp1 * ruvns(iii + 1);
    end

    return;
end

% AI 注释：
% 这段代码的主要目的是生成导频数据（Pilot Data），用于在无线通信系统中进行信道估计和同步。导频数据通常是一些已知的序列，通过这些序列，接收端可以估计信道的状态，从而进行信号的解调和解码。

% ### 代码的逻辑和步骤解释：

% 1. **组号 `u` 的确定：**
%    - 如果组跳频（group hopping）无效（`group_hop_flag == 0`），则组号 `u` 直接由 `fss` 和 `deltass` 计算得到。
%    - 如果组跳频有效（`group_hop_flag == 1`），则通过伪随机序列生成器 `pseudo_random_seq_gen` 生成一个伪随机序列 `cgroup`，并根据这个序列计算 `fghns`，最终确定组号 `u`。

% 2. **组内序列号 `v` 的确定：**
%    - 如果资源块数 `rbnum` 小于 6，或者组跳频无效且序列跳频有效（`seq_hop_flag == 1`），则通过伪随机序列生成器 `pseudo_random_seq_gen` 生成一个伪随机序列 `cseq`，并根据这个序列计算 `v`。
%    - 否则，`v` 直接设为 0。

% 3. **基本序列生成：**
%    - 根据资源块数 `rbnum` 的不同，生成不同长度的基本序列 `ruvns`。
%    - 如果 `rbnum` 为 1 或 2，直接使用预定义的矩阵 `fai_12sc` 或 `fai_24sc` 生成基本序列。
%    - 如果 `rbnum` 大于等于 3，则根据质数表 `prime_table` 确定序列长度 `nrszc`，并生成一个长度为 `nrszc` 的序列 `xqm`，然后将这个序列扩展到 `mrssc` 长度。

% 4. **计算相位旋转 `alpha`：**
%    - 通过伪随机序列生成器 `pseudo_random_seq_gen` 生成一个伪随机序列 `cseq`，并根据这个序列计算 `nprs`。
%    - 结合 `ndmrs1`、`ndmrs2_table` 和 `nprs` 计算 `ncs`，最终得到相位旋转 `alpha`。

% 5. **生成最终的导频序列：**
%    - 对基本序列 `ruvns` 进行相位旋转 `alpha`，得到最终的导频序列 `out`。

% ### 代码的关键点：

% - **伪随机序列生成器 `pseudo_random_seq_gen`**：这个函数用于生成伪随机序列，这些序列用于确定组号 `u`、组内序列号 `v` 以及相位旋转 `alpha`。伪随机序列的生成是基于初始值 `cinit` 和序列长度。

% - **质数表 `prime_table`**：用于确定序列长度 `nrszc`，特别是在资源块数 `rbnum` 大于等于 3 的情况下。质数表确保生成的序列具有良好的自相关和互相关特性。

% - **相位旋转 `alpha`**：通过相位旋转，可以进一步增加导频序列的随机性，从而提高信道估计的准确性。

% ### 总结：

% 这段代码通过一系列的计算和伪随机序列生成，生成了一个具有良好自相关和互相关特性的导频序列。这个序列可以用于无线通信系统中的信道估计和同步，从而提高通信的可靠性和性能。
