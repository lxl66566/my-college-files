#import "./template.typ": *
#import "@preview/tablex:0.0.9": tablex, colspanx, rowspanx
#import "@preview/tablem:0.1.0": tablem


#show: project.with(
  title: "LTE移动通信物理层协议关键算法的仿真与实现",
  authors: ("absolutex",),
)

#title("LTE移动通信物理层协议关键算法的仿真与实现")

= 实践目的

+ 掌握LTE移动通信物理层协议实验的流程、原理及实现方法。
+ 掌握通过MATLAB编程实现LTE移动通信物理层协议实验的设计。

= 实践内容
== 验证性实验
+ 理解 LTE移动通信物理层协议组成及各模块原理，搭建系统框图。
+ 配置实验参数，通过对应实验结果理解参数对结果的影响。
== 设计性实验
+ 浏览参考代码中的全部程序，理解实验代码。
+ 在设计代码的TDLTE_Cdblk_seg1.m 文件里补充码块分割部分代码。
+ 在设计代码的TDLTE_Cdblk_concate1.m 文件里补充码块级联部分代码。
+ 在设计代码的TDLTE_modfun.m 文件里补充调制映射部分的代码。
+ 在设计代码的 TDLTE_genantdata.m 文件里补充天线时域数据产生部分的代码。

= 基础实验部分

// 填写说明：基础实验部分只写上述7个算法的设计过程，如算法流程图、代码分析、实验结果等等，自拟小标题。
// 注：摘抄指导书的部分略，重点侧重代码设计和实验结果分析。

== CRC的设计与实现

CRC 是一种广泛应用于数据通信和存储中的错误检测技术，通过在数据传输或存储过程中添加冗余信息，以确保数据的完整性和准确性。而生成多项式在 CRC 算法中扮演着至关重要的角色，它决定了校验码的生成方式和检测错误的效率。

本次实验使用的 CRC 校验位为 24 位，生成多项式系数为1100001100100110011111011。

#figure(
  image("assets/crc.png", width: 25%),
  caption: [CRC 添加流程],
)

#include_code("../code/TDLTE_add_crc.m")

此代码的添加 CRC 校验的具体步骤为：

+ 附加零位：在原始数据尾部添加 24 个 0
+ 循环二进制除法（异或）
+ 求得 24 位余数即为 CRC 校验码

大致流程与理论是相符的。

== 码块分割的设计与实现

当传输块达到 6144 位时需要进行码块分割。码块分割的意义是：

+ 适应编码器要求：规范要求 Turbo 编码器的输入数据块长度最大为 6144 bits。为了满足这个要求，需要将输入数据分割成较小的码块。
+ 提高编码效率：通过将大块数据分割成较小的块，可以更有效地进行编码和解码处理，减少误码率。
+ 增强鲁棒性：分割后的码块在传输过程中可以独立处理和传输，即使某些码块丢失或出错，也不会影响整个传输块的解码。

#figure(
  image("assets/blk_seg.png", width: 25%),
  caption: [码块分割流程],
)

程序的码块分割会将输入数据分割成两种不同长度的码块（K+ 和 K-），并在每一个码块尾部添加 CRC 校验位。假设分割的全部为 K+ 码块，则其所能覆盖的总长度将大于实际长度，因此取表中 K+ 的前面一个长度为 K- 即为短码块的长度，这样可以让所有码块长度总和尽可能接近原始数据的长度。

#include_code("../code/TDLTE_Cdblk_seg1.m")

== 调制的设计与实现

调制就是将 bit 流映射为星座图上的点的过程。对于 QPSK，16QAM，64QAM 调制方式，其数据位数分别为 2, 4, 6，将此设为 b。调制每次从数据流中取出 b 位 01 bit 作为二进制数据，并将该二进制的值对应到映射表中的每个点上，并输出到 out。

#include_code("../code/TDLTE_modfun.m")

== 产生导频数据的设计与实现

导频数据（Pilot Data）用于在无线通信系统中进行信道估计和同步。导频数据通常是一些已知的序列，通过这些序列，接收端可以估计信道的状态，从而进行信号的解调和解码。

#figure(
  image("assets/pusch.png", width: 20%),
  caption: [导频数据生成流程],
)

代码中的生成导频流程：

1. 组号 `u` 的确定：
  - 如果组跳频无效（`group_hop_flag == 0`），则组号 `u` 直接由 `fss` 和 `deltass` 计算得到。
  - 如果组跳频有效（`group_hop_flag == 1`），则通过伪随机序列生成器 `pseudo_random_seq_gen` 生成一个伪随机序列 `cgroup`，并根据这个序列计算 `fghns`，最终确定组号 `u`。
2. 组内序列号 `v` 的确定：
  - 如果资源块数 `rbnum` 小于 6，或者组跳频无效且序列跳频有效（`seq_hop_flag == 1`），则通过伪随机序列生成器 `pseudo_random_seq_gen` 生成一个伪随机序列 `cseq`，并根据这个序列计算 `v`。
  - 否则，`v` 直接设为 0。
3. 基本序列生成：
  - 根据资源块数 `rbnum` 的不同，生成不同长度的基本序列 `ruvns`。
  - 如果 `rbnum` 为 1 或 2，直接使用预定义的矩阵 `fai_12sc` 或 `fai_24sc` 生成基本序列。
  - 如果 `rbnum` 大于等于 3，则根据质数表 `prime_table` 确定序列长度 `nrszc`，并生成一个长度为 `nrszc` 的序列 `xqm`，然后将这个序列扩展到 `mrssc` 长度。
4. 计算相位旋转 `alpha`：
  - 通过伪随机序列生成器 `pseudo_random_seq_gen` 生成一个伪随机序列 `cseq`，并根据这个序列计算 `nprs`。
  - 结合 `ndmrs1`、`ndmrs2_table` 和 `nprs` 计算 `ncs`，最终得到相位旋转 `alpha`。
5. 生成最终的导频序列：
  - 对基本序列 `ruvns` 进行相位旋转 `alpha`，得到最终的导频序列 `out`。


```m
% prime_table：一个预定义的质数列表，用于后续确定序列长度。
% ndmrs2_table：一个预定义的数值表，用于计算ncs值。
% fai_12sc：一个预定义的矩阵，用于生成长度为12个子载波的基本序列。

%确定组号u的具体取值；
if (group_hop_flag == 0)%组跳频无效
    fghns = 0;
else
    cinit = floor(cellid / 30);
    cgroup = pseudo_random_seq_gen(cinit, 180);
    sum = 0;

    for (iii = 0:7)
        sum = sum + cgroup(8 * slotno + iii + 1) * (2^iii);
    end

    fghns = mod(sum, 30);
end

fss = mod(cellid, 30);
fss = mod((fss + deltass), 30);
u = mod(fghns + fss, 30);

%确定组内序列号v的具体取值；
if (rbnum < 6)
    v = 0;
elseif (group_hop_flag == 0) & (seq_hop_flag == 1)
    cinit = floor(cellid / 30) * 32 + fss;
    cseq = pseudo_random_seq_gen(cinit, 180);
    v = cseq(slotno);
else
    v = 0;
end

%基本序列生成
mrssc = rbnum * 12;

if (rbnum == 1)%序列长度为12个子载波

    for (iii = 1:mrssc)
        ruvns(iii) = exp(j * pi / 4 * fai_12sc((u + 1), iii)); %
    end

elseif (rbnum == 2)%序列长度为24个子载波

    for (iii = 1:mrssc)
        ruvns(iii) = exp(j * pi / 4 * fai_24sc((u + 1), iii)); %
    end

else %序列长度大于等于36个子载波。
    nrszc = prime_table(rbnum); %by maoxuewei @2090324
    qs = nrszc * (u + 1) / 31;
    q = floor(qs + 0.5) + v * ((-1)^(floor(2 * qs)));

    for (iii = 1:nrszc)
        xqm(iii) = exp(-j * pi * q * (iii - 1) * iii / nrszc);
    end

    for (iii = 1:mrssc)
        ruvns(iii) = xqm(mod((iii - 1), nrszc) + 1);
    end

end

basic_out = ruvns;
%计算a的值,并得到最后的序列
cinit = floor(cellid / 30) * 32 + fss;
cseq = pseudo_random_seq_gen(cinit, 1120); % based on 3GPP 36211-850
nprs = 0;

for (iii = 0:7)
    nprs = nprs + cseq(slotno * 8 * 7 + iii + 1) * (2^iii);
end

ncs = mod(ndmrs1 + ndmrs2_table(cyc_shift + 1) + nprs, 12);
alpha = 2 * pi * ncs / 12;

for (iii = 0:mrssc - 1)
    temp1 = exp(j * iii * alpha);
    out(iii + 1) = temp1 * ruvns(iii + 1);
end

return;
```

== 产生频域数据的设计与实现


#include_code("../code/TDLTE_genFredata.m")

== 产生时域数据的设计与实现

#include_code("../code/TDLTE_genantdata.m")

== 时域数据变频域数据的设计与实现

#include_code("../code/TDLTE_fftantdata.m")

= 综合设计部分

// 填写说明：综合设计部分，指的是项目从信源到信宿的完整实现过程，包括要求编写的程序，也包括不要求编写的程序（理解、读懂）。自拟标题，有逻辑的将整个实现过程描述清楚。包括但不限于系统总体组成、系统各组成模块功能分析、系统参数分析（这是重点，要求将不同参数配置情况下的运行结果以表格形式进行对比，分析该参数的作用，分析不同参数对实验结果的影响，以及为什么会产生这种影响等等）

== 系统总体组成

#figure(
  image("assets/connect.png", width: 60%),
  caption: [系统整体框图],
)

在 LTE 系统中，数据传输的过程可以分为多个步骤。

在发送端，源数据会被添加 CRC 校验码以确保数据的完整性。接下来，数据会被分割成多个码块，然后进行 Turbo 编码和速率匹配，以适应信道传输的要求。之后，数据会经过码块级联、交织和加扰等处理，以增强抗干扰能力。接下来，数据会被调制并映射到频域资源上，然后通过频域到时域的转换进行传输。

在接收端，信号会经过时域到频域的转换、信道估计、均衡和解调等步骤，初步恢复传输的数据。然后，数据会经过解扰、解交织、Turbo 解码、解速率匹配和码块拆分等处理，逐步还原成原始数据。最后，利用 CRC 校验码验证数据的完整性，并将解码后的数据传递给最终的接收者。

通过这些步骤，LTE 系统能够有效地传输数据，同时尽可能增加数据的完整性和抗干扰能力。


== 系统各组成模块功能分析


+ CRC：纠错码，24 位添加到原始信号尾部。
+ 码块分割：将长的数据流分割成多个小的数据块，以便于后续处理。实际代码中分割为两种不同大小（K(i) and K(i-1)）的码块。先切小块再切大块。码块分割主要因为 turbo coding 有 size 要求，max 6144 bits。(http://ee.mweda.com/rd/165953.html)
+ Turbo 编码：误码恢复。采用两个并行级联的卷积编码器，中间加入交织器来打乱数据顺序，以增加编码的多样性。输出三倍长度。
+ 速率匹配：调整编码后的比特率以适应传输信道的特性。可能涉及重复某些比特或删除部分比特，以达到所需的比特率。（打多少由信道决定）
+ 码块级联：将编码后的多个码块重新连起来。
+ 交织：对抗突发错误。按照一定的规则重新排列数据位的位置，使得原本相邻的数据位在传输过程中不会因为信道的突发错误而同时丢失。（变为分散丢失）
+ 加扰：改善信号的频谱特性，减少连续‘0’或‘1’的影响。通过与一个已知的伪随机序列进行异或操作来改变数据模式。
+ 调制：将数字信号转换为适合无线传输的模拟信号。使用不同的调制方案（如 QPSK、16QAM 等）将数据映射到相应的星座点上。
+ 生成导频数据：帮助接收端进行信道估计和同步。在数据流中插入已知的参考符号。
+ 资源映射：将调制后的符号分配到可用的子载波上。根据系统的多载波调制方式（如 OFDM），将数据符号放置到正确的频率位置。
+ 信道估计：估计信道响应，用于补偿传输过程中的失真。利用导频数据计算信道状态信息。
+ 解速率匹配：恢复原始的数据。去除速率匹配过程中添加的额外比特或恢复删除的比特。


== 系统参数分析

=== QPSK, 40 db

#figure(
  image("assets/QPSK40/1.png", width: 70%),
  caption: [系统星座图。左：发送端；右：接收端],
)

#figure(
  image("assets/QPSK40/2.png", width: 100%),
  caption: [系统信号。左：发送信号；中：接收信号；右：接收信号频谱],
)

=== 16QAM, 40 db

#figure(
  image("assets/16QAM40/1.png", width: 70%),
  caption: [系统星座图。左：发送端；右：接收端],
)

#figure(
  image("assets/16QAM40/2.png", width: 100%),
  caption: [系统信号。左：发送信号；中：接收信号；右：接收信号频谱],
)

=== 64QAM, 40 db

#figure(
  image("assets/64QAM40/1.png", width: 70%),
  caption: [系统星座图。左：发送端；右：接收端],
)

#figure(
  image("assets/64QAM40/2.png", width: 100%),
  caption: [系统信号。左：发送信号；中：接收信号；右：接收信号频谱],
)

=== 16QAM, 0 db

#figure(
  image("assets/16QAM0/1.png", width: 70%),
  caption: [系统星座图。左：发送端；右：接收端],
)

#figure(
  image("assets/16QAM0/2.png", width: 100%),
  caption: [系统信号。左：发送信号；中：接收信号；右：接收信号频谱],
)

=== 64QAM, 0 db

#figure(
  image("assets/64QAM0/1.png", width: 70%),
  caption: [系统星座图。左：发送端；右：接收端],
)

#figure(
  image("assets/64QAM0/2.png", width: 100%),
  caption: [系统信号。左：发送信号；中：接收信号；右：接收信号频谱],
)


#tablex(
  columns: 5,
  align: center + horizon,
  header-rows: 1,
  // header
  [调制方式],
  [传输信息比特],
  [信噪比dB],
  [误码数
    （调制映射输入和解调制映射输出）],
  [误码数
    （信源和信宿）],
  // row1
  rowspanx(3)[QPSK],rowspanx(3)[28800],[40],[0],[0],
  // row2
  (),(),[20],[8],[0],
  // row3
  (),(),[0],[232],[0],

  // row4
  rowspanx(3)[16QAM],rowspanx(3)[57600],[40],[0],[0],
  // row5
  (),(),[20],[8],[0],
  // row6
  (),(),[0],[6360],[3815],


  // row7
  rowspanx(3)[64QAM],rowspanx(3)[86400],[40],[16],[0],
  // row8
  (),(),[20],[40],[0],
  // row9
  (),(),[0],[17544],[12842],
)


根据实验数据，我们可以得出以下结论：在不同调制方式下，信噪比对误码率的影响显著。

+ 对于QPSK调制方式，当信噪比为40dB时，误码数为0，表明在高信噪比下，QPSK调制方式具有较高的抗干扰能力。然而，当信噪比降至20dB和0dB时，误码数分别增加到8和232，显示出信噪比降低对误码率的显著影响。
+ 对于16QAM调制方式，信噪比为40dB时，误码数同样为0，显示出在高信噪比下，16QAM调制方式也能保持较低的误码率。然而，当信噪比降至20dB和0dB时，误码数分别增加到8和6360，且信源和信宿之间的误码数也显著增加到3815，表明16QAM调制方式在低信噪比下的抗干扰能力较弱。
+ 对于64QAM调制方式，信噪比为40dB时，误码数为16，显示出即使在高信噪比下，64QAM调制方式的误码率也较高。当信噪比降至20dB和0dB时，误码数分别增加到40和17544，且信源和信宿之间的误码数也显著增加到12842，表明64QAM调制方式在低信噪比下的抗干扰能力最弱。

随着调制方式的复杂度增加，系统对信噪比的要求也随之提高。在实际应用中，应根据具体的信道条件选择合适的调制方式，以平衡传输效率和误码率。

= 收获与体会

通过这次TD-LTE移动通信物理层协议实验，我深刻体会到了现代通信技术的复杂性和精密性。实验的每一个步骤都需要严谨的态度和细致的操作，从信源的产生到最终信号的接收，每一个环节都至关重要。

首先，通过实验，我掌握了LTE移动通信物理层协议的基本流程和原理。LTE物理层链路的各个模块，如CRC添加、Turbo编码、速率匹配、交织、加扰、调制等，都是确保数据可靠传输的关键步骤。每一个模块的设计和实现都需要深入理解其背后的理论知识，这让我对通信系统的整体架构有了更全面的认识。

其次，通过MATLAB编程实现LTE物理层协议的设计，使我在编程能力和实际应用方面得到了提升。MATLAB作为一种强大的工具，不仅帮助我实现了复杂的算法，还让我能够直观地观察和分析数据的变化。这种理论与实践相结合的学习方式，使我对通信技术有了更深刻的理解。

此外，实验还让我体会到了团队合作的重要性。在实验过程中，和同学们一起讨论问题、解决难题，不仅提高了我们的协作能力，也增强了我们的团队凝聚力。每个人在实验中的不同分工和贡献，使得整个实验过程更加顺利和高效。
